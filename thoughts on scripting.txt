== Thoughts on the scripting system (similar to ICARUS in Jedi Academy) ==

* Scripts are coroutines. Wait causes them to yield.
* Time waited to long should be taken into account. (reduces the time of all following time-based commands)
* One "default" script, which is usually overwritten by target_scriptrunners - affects can either overwrite ("flush") or "insert"
  * -> script stack (LIFO)
* allow other scripts to run in parallel? Not necessary, can be achieved using tasks and "insert"-affects.

=== What should the JKA commands look like? ===

* self variable contains affected entity
* flush clears the script stack
* if/else/loop are available through Lua
* function environment has a metatable with __index and __newindex - global Lua variables become global variables (declare, set, free in JKA) but self and other existing functions cannot be overwritten
* tasks create coroutines:
task("my task", function() print("foobar") end)
(the actual coroutine isn't created until do("my task") is called.)
* print, kill, remove, use, setcvar, signal, camera, sound, play(roff), move, rotate behave as in JKA (same channel behaviour as in jka? well, that's a sound system question and not that important here)
* run = dofile
* wait(task/time), dowait(task), waitsignal behave the same as well, but internally yield.
* what about set() commands that take time? They should usually not wait, unless they're called within a task... Tasks are the only thing that doesn't count as complete until all set commands are executed
  * -> sets should record whether they're done somewhere - but attention: a newer set can overwrite an earlier, causing the latter to never be complete. So only keep track of each settable variable once.
* how set is going to work depends on how the entity settings work... but having a set function seems sensible (so I can handle non-instant sets accordingly) - I should use strings instead of enums (ints) though, for better extendability (and easier handling as well)

=== Things to keep in mind ===

Parameters may be instructions themselves - e.g. move(tag("foo", origin), get(SET_PARM1))
To get proper intendation, blocks need to keep track of their level
Some global variable names that are OK in JKA won't work anymore (things called like functions)
global variable names may include spaces - use _G["name"]?
Booleans are strings ("true", "false")
if and else are two different blocks, i.e. between them theres an ID_BLOCK_END


=== Trivial Commands ===

Commands that don't need much further processing beyond parameter sanitizing - attention: parameter may be funtion :-/ -> no sanitizing at all?

